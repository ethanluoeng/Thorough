[{"page": 1, "text": "Lab Exercise 6: Sorting [10 Marks]\nAISE/SE2205: Data Structures and Algorithms using Java \u2013 Fall 2025\nOpen Day: November 17, 2025; Cut off time: November 23, 2025, Sunday 11.59pm\nPrepared by Dr. Quazi Rahman (qrahman3@uwo.ca).\nA. Rationale and Background\nIn this lab Assignment, for question 1, we will write all the sorting methods we discussed in the class\nin their generic form (except for Bucket-sort) and check their execution time for an Integer type\ndataset. For question 2 we will create a StudentGrade type class, and then after populating a list with\ncertain number of students and their corresponding grades, we will sort that list based on last name, or\nfirst name or the grade.\nB. Evaluation and Submission Instructions\nSubmit your Lab-Exercise online by carrying out the following instructions:\n1. Create a Project with the following name: username_LabExercise6\n2. For this question create a package for each Question (LE6Q1, LE6Q2,)\n3. Use meaningful names for each class and the associated variables by following the general\nnaming conventions.\n4. For this question, use the static header and footer methods your created before.\n5. Comments: Writing short but clear comments for Lab Exercises is mandatory. If the\ncomments are clear, full credit will be given to the written comments.\n6. Once the Exercise is completed, go to your \u2018Project\u2019 folder. Select the project folder (e.g.\nusername_LabExercise5). Then scroll down to \u2018open in\u2019. This will have some options. You\nwill select \u2018Explorer\u2019 (or for MAC it is \u2018Finder\u2019). And then inside the explorer, click on the\nproject name and scroll down to \u2018Compressed to\u2019 (for MAC book it is about the same) and\ncompress this to .zip. It will create a zip file which you need to upload. Upload this file to\nOWL as your submission.You will be graded on this lab Exercise based on the comments and\nrunning code.\n7. Note: if your code does not run, zero grade will be awarded even if it is a minor fix. No\nextension is available for this lab.\nC. Lab Question\n1. Question 1 [7 Marks]\nMost of the required codes associated to this question have been made available\neither in the lecture-handout or in the Unit 4 Companion Document.\n(a) Define a class called YourFirstnamesTestingSortingMethods. Inside the class, define the\nfollowing generic sorting methods, where each method accepts a generic array and returns the\ntime elapsed in sorting the array (use System.nanoTime() method as you did for first lab\nexercise; also, you can check Unit 2, P3 for nanoTime() method-usage in a code):\n\u2022 public static <T extends Comparable <? super T>>long selectionSort (T [] a)\n\u2022 public static < T extends Comparable <? super T >> long bubbleSort(T[] a)\n\u2022 public static < T extends Comparable <? super T >> long insertionSort(T[] a)\nLab Exercise 6 AISE/SE2205a QMR 1", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}, {"page": 2, "text": "\u2022 public static <T extends Comparable<? super T>> long mergeSort(T[] S) [you can tweak the\nrecursive merge-sort code given in the Unit 4 \u2013 companion document]\n\u2022 public static <T extends Comparable<? super T>> long quickSort(T[] s, int a, int b)[you can\nimplement the in-place recursive quick-sort algorithm given in the lecture handout]\n\u2022 public static long bucketSort(Integer[] a, int first, int last, int maxDigits) [You are not supposed\nto make it generic becaus it can only be used for specific data-sets. To understand the method-\nheader, please check the algorithm first, which is given in the lecture handout, and it is\nimplemented and given in the Unit 4 \u2013 companion document. You can use it as is.]\n(b) Define the driver method with the following specs.\ni) Call your header method (Reuse from the previous labs).\nii) Declare an Integer type array of size \u2018sz\u2019 which you can pre-set to 5.\niii) Create a backup Integer type array with the same size.\niv) Populate the first array with random values from 13 to 93 inclusive, by using\nMath.random() method.\nv) Copy the content of the first array to the backup array (You can use\nSystem.arraycopy() method).\nvi) Create a List<> for the above Integer Array using asList() method from Arrays class\n(List<Integer> = Arrays.asList(arrayName);) This will help you take advantage of\nList<>'s toString() method.\nvii) Sort the first array using Collections\u2019 sort method. Print both the sorted and unsorted\narrays with the help of List<>\u2019s toString() metod. Check the time and print it on the\nscreen (see the sample output).\nviii) Now copy the backup array to the first array (you need to do this to make sure that\nyou are sorting the same unsorted array every time)\nix) Call your selectionSort() method by passing the first array, and print the time along\nwith the sorted and unsorted array contents.\nx) Repeat step viii) before calling bubble, insertion, merge, quick and bucket sort\nmethods, and print the unsorted array, sorted array and the elapsed time for every\nscenario. See the sample output 1.\nxi) Since you will not get a clear idea of the elapsed time with a dataset of 5 items only,\nchange the size to 50,000. Now repeat all the above after commenting out the sorted\nand unsorted array-printing calls. See the sample output 2. During your demo, your\nTA may ask you to change the size back to 5, uncomment those print statements,\nand demo that your code is sorting the array properly.\nxii) Call your footer method (Reuse from previous lab).\n(c) Note: Based on the processor speed, memory usage etc., your code-execution time will not be\nsame as shown in the sample output but fundamentally, you should observe that Collections\nsorting method will be faster than selection, bubble, and insertion sorts. Bubble sort will take\nthe maximum execution time. Bucket sort will generate fastest execution time. Merge sort and\nquick sort execution time will be better than the bubble, insertion, and selection sorts. For\nsmaller dataset, quick sort, merge sort will perform worse than the others. Collections\u2019 sort\nmethod will be the fastest. Java\u2019s sort (in Collections, Arrays etc.) methods implements Timsort\nalgorithm (https://en.wikipedia.org/wiki/Timsort) which is a combination of merge and\ninsertion sort.\nSample output 1 (With printed array content):\n=======================================================\nLab Exercise 6, Q1\nPrepared By: Quazi Rahman\nLab Exercise 6 AISE/SE2205a QMR 2", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}, {"page": 3, "text": "Student Number: 999999999\nGoal of this Exercise: ........!\n=======================================================\nTesting execution time of different sorting methods for sorting 5 random numbers:\nThe unsorted list: [39, 25, 14, 65, 83]\nCollections' Sorting Time: 0.14 milliseconds\nThe sorted list using Collections' sort method: [14, 25, 39, 65, 83]\nThe unsorted list: [39, 25, 14, 65, 83]\nMy Selection-Sort Time: 0.01 milliseconds\nThe sorted list using selection-sort: [14, 25, 39, 65, 83]\nThe unsorted list: [39, 25, 14, 65, 83]\nMy Bubble-Sort Time: 0.00 milliseconds\nThe sorted list with Bubble-sort: [14, 25, 39, 65, 83]\nThe unsorted list: [39, 25, 14, 65, 83]\nMy Insertion-Sort Time: 0.00 milliseconds\nThe sorted list with Insertion-sort): [14, 25, 39, 65, 83]\nThe unsorted list: [39, 25, 14, 65, 83]\nMy Merge-Sort Time: 0.01 milliseconds\nThe sorted list with Merge-sort): [14, 25, 39, 65, 83]\nThe unsorted list: [39, 25, 14, 65, 83]\nMy Quick-Sort Time: 0.00 milliseconds\nThe sorted list with Quick sort): [14, 25, 39, 65, 83]\nThe unsorted list: [39, 25, 14, 65, 83]\nMy Bucket-Sort Time: 0.26 milliseconds\nThe sorted list with Bucket-sort): [14, 25, 39, 65, 83]\n=======================================================\nCompletion of Lab Exercise 6, Q1 is successful!\nSigning off - Quazi\n=======================================================\nSample output 2 (Without printing the arrays):\n=======================================================\nLab Exercise 6, Q1\nPrepared By: Quazi Rahman\nStudent Number: 999999999\nGoal of this Exercise: ........!\n=======================================================\nTesting execution time of different sorting methods for sorting 50000 random numbers:\nCollections' Sorting Time: 17.39 milliseconds\nMy Selection-Sort Time: 1565.16 milliseconds\nMy Bubble-Sort Time: 5997.24 milliseconds\nMy Insertion-Sort Time: 1870.57 milliseconds\nMy Merge-Sort Time: 33.28 milliseconds\nMy Quick-Sort Time: 114.83 milliseconds\nLab Exercise 6 AISE/SE2205a QMR 3", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}, {"page": 4, "text": "My Bucket-Sort Time: 10.81 milliseconds\n=======================================================\nCompletion of Lab Exercise 6, Q1 is successful!\nSigning off - Quazi\n=======================================================\n2. Question 2 [3 Marks]\n(a) Create a class Called StudentGrade that implements Comparable<> interface with the\nfollowing specs:\n\u2022 The class header:\npublic class StudentGrade implements Comparable<StudentGrade>\n\u2022 Three private data fields: firstName, lastName, grade.\n\u2022 A Constructor with no parameters (empty body); it is optional\n\u2022 A Constructor with all the parameters (firstName, lastName, grade).\n\u2022 All the Getter and setter methods for all three data fields, even if you do not need to use\nall.\n\u2022 Implement the CompareTo() method to compare the grades.\n\u2022 Override toString() method so that it can print the list as shown in the sample output for\nthe unsorted list, and the sorted list based on the grades.\n\u2022 The other two sored list based on the last names and first names, need to be printed\nseparately; in this case, you need to create a public static void method called printArray()\nwith appropriate parameter list in the driver class, and accomplish this task.\n(b) Create a driver class YourFirstName_SortNameAndGrade. Add the public static sort() method,\nthe printArray() method, header method, footer method, and the given driver method (see\nbelow) in your code and complete the rest of the code based on the commented instructions\nbelow:\npublic static void main(String[] args) {\n//call your header method\n//Three arrays with 8 first names, 8 last names and 8 randomly\ngenerated grades between 60 and 85 inclusive have been created below\nfor your use\nString[] fnArray = {\"Hermione\", \"Ron\", \"Harry\", \"Luna\", \"Ginny\",\n\"Draco\", \"Dean\", \"Fred\"};\nString[] lnArray = {\"Granger\", \"Weasley\", \"Potter\", \"Lovegood\",\n\"Weasley\", \"Malfoy\", \"Thomas\", \"Weasley\"};\nInteger[] grd = {(int)(60 + Math.random()*26),(int)(60 +\nMath.random()*26),(int)(60 + Math.random()*26),(int)(60 +\nMath.random()*26),(int)(60 + Math.random()*26),(int)(60 +\nMath.random()*26),(int)(60 + Math.random()*26),(int)(60 +\nMath.random()*26)};\n//create a Vector<> class instance \u2018sg\u2019 with StudentGrade tag.\nLab Exercise 6 AISE/SE2205a QMR 4", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}, {"page": 5, "text": "//Add each StudentGrade object to the Vector class with its add() method (Slide #36, Unit 2 Part 2)\n//print the unsorted \u2018sg\u2019 contents just by using toString() method (see the sample output)\n//sort \u2018sg\u2019 using Collections\u2019 sort method, which will sort the list based on the grade\n//print the sorted content by using toString() method (see the sample output)\n//Create an array of StudentGrade type with the length of the fnArray that has been created above.\n//with the help of Vector\u2019s copyInto() method (Slide #36, Unit 2 Part 2), copy \u2018sg\u2019 to StudentGrade\narray you just created above\n//At this point tweak the stable sorting method (your created in Q1), insertion sort that will accept a\nStudentGrade array and an integer key (alternatively, you can tweak merge sort). Define this public\nstatic void method outside the driver method below. The integer key in the method header will decide\nwhether you would like to sort the StudentGrade array according to the first name (key = 1) or the last\nname (key = 2). Once done, come back to this place inside the driver and call your sort-method with\nthe argument of StudentGrade array (you created above) and key = 1 (first names).\n//print the sorted array (see the sample output) with the aid of your printArray() method\n// Call your sort-method again with the argument of StudentGrade array (you created above) and key =\n2.\n//print the sorted array (see the sample output) with the aid of your printArray() method\n//call your footer method here\n}\n//Your sort-method() will go here.\n//Add your printArray() method here.\nNote: Since the grades are generated using Math.random() method, the grades will vary in every run.\nSample output:\n---------------------\n=======================================================\nLab Exercise 6, Q2\nPrepared By: Quazi Rahman\nStudent Number: 999999999\nGoal of this Exercise: ........!\n=======================================================\nLab Exercise 6 AISE/SE2205a QMR 5", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}, {"page": 6, "text": "The Unsorted Array ................\nHermione Granger : 84\nRon Weasley : 79\nHarry Potter : 84\nLuna Lovegood : 77\nGinny Weasley : 71\nDraco Malfoy : 69\nDean Thomas : 75\nFred Weasley : 80\nSorted by Grades......................\nDraco Malfoy : 69\nGinny Weasley : 71\nDean Thomas : 75\nLuna Lovegood : 77\nRon Weasley : 79\nFred Weasley : 80\nHermione Granger : 84\nHarry Potter : 84\nSorted by First Names .............\nDean Thomas : 75\nDraco Malfoy : 69\nFred Weasley : 80\nGinny Weasley : 71\nHarry Potter : 84\nHermione Granger : 84\nLuna Lovegood : 77\nRon Weasley : 79\nSorted by Last Names...............\nHermione Granger : 84\nLuna Lovegood : 77\nDraco Malfoy : 69\nHarry Potter : 84\nDean Thomas : 75\nFred Weasley : 80\nGinny Weasley : 71\nRon Weasley : 79\n=======================================================\nCompletion of Lab Exercise 6, Q2 is successful!\nSigning off - Quazi\n=======================================================\nLab Exercise 6 AISE/SE2205a QMR 6", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}, {"page": 7, "text": "Here are some sample questions for your demo-prep. The TAs can ask any kind of\nquestion if those are related to this lab.\n1. What is \u2018natural order\u2019.\n2. What is \u2018order by comparator\u2019.\n3. What do you need to do if you would like to sort the instantiated objects of a\nclass called \u2018MyClass\u2019 using natural order?\n4. What is stability of sorting algorithm.\n5. How the stability of a sorting algorithm is ensured.\n6. Can any sorting algorithm be made stable?\n7. What are the inherently stable sorting algorithms?\n8. Can Radix sort be used to sort the instantiated objects of a class called\n\u2018MyClass\u2019. What is the reasoning of your response?\n9. If you sort an array with same dataset, with the same algorithm, in the same\nmachine twice, will the execution time for both runs will be the same? What is\nthe basis of your response?\n10. How have you picked the pivot in the quick sort algorithm? What is the\njustification of this choice?\n11. If you call the quick-sort method to sort an already sorted array based on the\nimplementation you presented what would happen in terms of time and space\ncomplexity. What is the basis of your response?\n12. Modify any algorithm to do the sorting in descending order.\n13. Explain how you generate a random number between min and max inclusive using\nMath.random() method.\n14. If you have a smaller dataset of 50 elements, which algorithm would you choose\nto sort that set, and why?\n15. If you create a class MyClass that implements Comparable<T> interface, would\nyou prefer choosing primitive datatype (when needed) over Wrapper class object\nreference. What is the basis of your response?\n16. If you would like to do Bucket-search Strings that use alphabetical characters,\nhow many buckets would you need to accomplish this? Why?\n17. What would be your preference between Merge and quick sort? Why?\n18. If you are sorting integer data set, what would be your sorting algorithm\nchoice? Why?\n19. Point out in the code, how the best-case time complexity of Insertion sort is\nO(n). Also, do the same for Bubble sort.\nLab Exercise 6 AISE/SE2205a QMR 7", "chapter": {"chapter_id": 0, "chapter_title": "Preface"}}]